# Java Basic
## step01
- Exam00.java : 주석
- Exam01.java : 자바 프로그램 기본 구조 및 컴파일과 실행
- Exam02.java : 자바 패키지
- Exam03.java : 클래스 이름과 파일명 1
- Exam04.java : 클래스 이름과 파일명 2
- Exam05.java : 클래스 이름과 파일명 3
- Exam06.java : 클래스와 객체(물건), 메서드(기능,방법) 용어의 의미
- Exam07.java : 값의 표현(Literal)
- Exam08.java : 메모리와 숫자
- Exam09.java : 음수의 표현
- Exam10.java : 각 진수의 표현
- Exam11.java : 실수 값 표현
- Exam12.java : 논리 값 표현
- Exam13.java : 문자 값 표현
- Exam14.java : 특수 문자의 표현 - Escape 문자 사용

## step02
- Exam01.java : 값을 저장할 메모리 준비하기 - 변수 선언
- Exam02.java : 변수 선언과 값 저장
- Exam03.java : 정수 변수의 사용
- Exam04.java : 문자 변수의 사용
- Exam05.java : 배열의 선언
- Exam06.java : 배열에 값을 저장하고 꺼내기
- Exam07.java : 배열 초기화
- Exam08.java : 2차원 배열
- Exam09.java : 다차원 배열
- Exam10.java : 문자열 저장 - String
- Exam11.java : 문자열 배열

## step03
- Exam01.java : String 물건 만들기
- Exam02.java : 리터럴 String과 new String의 비교
- Exam03.java : 물건(object)과 이름표(reference)의 관계
- Exam04.java : 배열과 레퍼런스 관계
- Exam05.java : char[] 배열을 이용하여 String 물건 만들기
- Exam06.java : String 물건에 들어있는 문자열의 길이를 알아내기
- Exam07.java : String 주요 도구 사용법1, immutable object 개념
- Exam08.java : String 주요 도구 사용법2
- Exam09.java : String 주요 도구 사용법3 - 스태틱 메서드
- Exam10.java : String 주요 도구 사용법4
- Exam11.java : String 주요 도구 사용법5
- Exam12.java : String 주요 도구 사용법6
- Exam13.java : String 주요 도구 사용법7

## step04
- Exam01.java : 산술 연산자 사용
- Exam02.java : 비교 연산자 사용
- Exam03.java : 논리 연산자 사용
- Exam04.java : 조건 연산자 사용
- Exam05.java : 비트 연산자 사용
- Exam06.java : 비트 연산자 응용
- Exam07.java : 비트 이동 연산자
- Exam08.java : 할당 연산자
- Exam09.java : 전위 증가/감소 연산자
- Exam10.java : 후위 증가/감소 연산자
- Exam11.java : 전위/후위 연산자 수행원리 비교
- Exam12.java : 연산자 우선순위
- Exam13.java : 연산자 우선순위와 후위 연산자
- Exam14.java : 명시적 형변환과 암시적 형변환1
- Exam15.java : 명시적 형변환과 암시적 형변환2
- Exam16.java : 명시적 형변환과 암시적 형변환3
- Exam17.java : 암시적 형변환의 규칙
- Exam18.java : 명시적 형변환과 암시적 형변환 함께 사용하기

##step05
- Exam01.java : 블록과 변수
- Exam02.java : 조건문 if
- Exam03.java : 조건문 if ~ else
- Exam04.java : 조건문 if ~ else 중첩
- Exam05.java : 조건문 if ~ else 중첩2
- Exam06.java : 다중 분기 switch
- Exam07.java : 다중 분기 switch 2
- Exam08.java : 다중 분기 switch 3
- Exam09.java : switch 문에 사용할 수 있는 값의 종류
- Exam10.java : 반복문 while
- Exam11.java : 반복문 do ~ while
- Exam12.java : 반복문 for
- Exam13.java : 반복문 for와 배열
- Exam14.java : 반복문 for(:)
- Exam15.java : break와 continue
- Exam16.java : for 문 중첩하기
- Exam17.java : 중첩된 for 문 나가기 

##step06
- Exam01.java : 메서드 정의하기1
- Exam02.java : 메서드 정의하기2
- Exam03.java : 메서드 정의하기3
- Exam04.java : 메서드 정의하기4
- Exam05.java : 여러 개의 메서드 정의하기

##step07
- Exam01.java : class 문법을 이용하여 여러 개의 메서드를 묶기
- Exam02.java : 클래스 공용 변수 사용
- Exam03.java : 클래스 변수의 한계
- Exam04.java : 각 클래스마다 값을 개별적으로 관리하기
- Exam05.java : 메서드에 인스턴스 주소를 쉽게 전달하기

##step08
- Exam01.java : 클래스 구동원리 - 클래스 로딩과 메서드 실행
- Exam02.java : 클래스 구동원리 - 클래스 로딩과 메서드 실행2
- Exam03.java : 클래스 구동원리 - 클래스 메서드 사용과 클래스 로딩
- Exam04.java : 클래스 구동원리 - 인스턴스와 클래스 로딩
- Exam05.java : 클래스 구동원리 - 인스턴스와 클래스 로딩2
- Exam06.java : 클래스 구동원리 - 가비지와 가비지 컬렉터
- Exam07.c : dangling pointer(C)

##step09
- Exam01.java : 기본 데이터 타입만 사용하여 복잡한 데이터 다루기
- Exam02.java : class로 사용자 정의 타입 만들기
- Exam03.java : 생성자(constructor)와 기본 생성자
- Exam04.java : 파라미터를 갖는 생성자
- Exam05.java : 또 다른 인스턴스 초기화 문법 - 인스턴스 초기화 블록
- Exam06.java : 인스턴스 초기화 문장
- Exam07.java : 인스턴스 데이터를 다루는 연산자(operator) 추가하기

##step10
- Exam01.java : 캡슐화 적용 전
- Exam02.java : 캡슐화 적용 후
- Exam03.java : 캡슐화 적용 후2
- Exam04.java : 메서드의 접근 레벨
- Exam05.java : 다른 패키지의 클래스 사용 및 클래스 접근 레벨
- Exam06.java : 클래스 접근 레벨

##step11
- Exam01.java : 생성자 오버로딩
- Exam02.java : c, c++ 오버로딩
- Exam03.java : 메서드 오버로딩과 호출 규칙
- Exam04.java : 오버로딩을 잘못한 예

##step12
- Exam01.java : 스태틱 변수(클래스 변수)와 스태틱 블록
- Exam02.java : 스태틱 변수에 접근
- Exam03.java : 인스턴스 변수에 접근
- Exam04.java : 스태틱 변수의 사용
- Exam05.java : 인스턴스 변수의 사용
- Exam06.java : 생성자 사용
- Exam07.java : 생성자 오버로딩 사용
- Exam08.java : 캡슐화 적용
- Exam09.java : 스태틱 변수의 활용
- Exam10.java : 인스턴스 변수의 this 생략, 스태틱 변수의 클래스명 생략

##step13
- Exam01.java : 랩퍼(wrapper class) 클래스
- Exam02.java : 랩퍼(wrapper class) 클래스와 원시 타입 간 오토박싱(auto-boxing)
- Exam03.java : 날짜 데이터를 다루는 클래스
- Exam04.java : 날짜 데이터를 다루는 클래스2
- Exam05.java : 날짜 데이터를 다루는 클래스3
- Exam06.java : mutable 문자열 다루기
- Exam07.java : 프로그램 아규먼트
- Exam08.java : JVM 아규먼트
- Exam09.java : final
- Exam10.java : final 2
- Exam11.java : final 3

##step14
- Exam01.java : 상속
- exam02 : 상속 - Specialization(특화)
- exam03 : 상속 - Generalization(일반화)
- exam04 : 상속 - Generalization(일반화)
- exam05 : 오버라이딩(overriding)
- exam06 : 상속과 인스턴스 변수
- exam07 : 상속 관계에서 인스턴스 변수 초기화 순서와 생성자 호출 순서
- exam08 : 수퍼 클래스의 생성자 호출 확인
- exam09 : 수퍼 클래스에 기본 생성자가 없을 때 오류 발생하는 상황
- exam10 : 하위 클래스에서 부모 클래스의 protected 멤버에 접근하기 
- exam11 : super와 this 키워드

##step15
- Test.java : 다형적 변수
- exam02
	- Test.java : 다형적 변수의 제약
	- Test2.java : 왜 상위 클래스의 레퍼런스는 하위 클래스의 인스턴스를 가리킬 수 있는가?
	- Test3.java : 다형적 변수의 형변환
	- Test4.java : 다형적 변수에서 메서드 호출

##step16
- Exam01.java : java.lang.Object 클래스
- Exam02.java : toString() 오버라이딩
- Exam03.java : equals() 오버라이딩
- Exam04.java : equals() 오버라이딩
- Exam05.java : hashCode() 오버라이딩
- Exam06.java : 다시 toString() 오버라이딩

##step17
- Exam01.java : 키보드로부터 데이터 읽기

##step18
- exam01 : Generic

##step19
- Test1.java : 예외 처리 전
- Test2.java : 예외 처리 후
- Test3.java : 예외 정보 다루기
- Test4.java : 예외 객체의 다형성
- Test5.java : Exception 예외 다루기
- Test6.java : Exception 예외 다루기 2 - try ~ catch ~
- Test7.java : Exception 예외 다루기 3 - throws
- Test8.java : RuntimeException 예외 던지고 받기
- Test9.java : Exception 예외 던지고 받기
- Test10.java : RuntimeException의 이해 1 - 상위 호출자에게 자동 전달
- Test11.java : RuntimeException의 이해 2 - 활용법
- Test12.java : Exception의 이해
- Test13.java : throws의 다형성
- Test14.java : catch의 다형성
- Test15.java : catch의 다형성 - try 블록에 여러 예외가 있을 때
- Test16.java : 왜 Exception을 상속 받는가?

##step20
- exam01 : 중첩 클래스(Nested Class or Inner Class) 도입 전
- exam02 : 중첩 클래스(Nested Class or Inner Class) 도입 후
- exam03
	- Test1 : top level inner class 사용
	- Test2 : top level inner class 사용 2
	- Test3 : top level inner class 사용 3
	- Test4 : member inner class 사용
	- Test5 : local inner class 사용
	- Test6 : annonymous inner class 사용
	- Test7 : annonymous inner class 사용
	- Test8 : annonymous inner class 사용
- exam04 : 같은 멤버인 메서드에서 중첩 클래스 사용하기
- exam05
	- Test1 : 패키지 멤버 클래스를 이용한 상수 다루기
	- Test2 : 중첩 클래스를 이용한 상수 다루기

##step21
- Exam01.java : Collection API - ArrayList
- Exam02.java : Collection API - ArrayList2
- Exam03.java : Collection API - ArrayList3
- Exam04.java : Collection API - ArrayList4
- Exam05.java : Collection API - ArrayList5 --> 로컬 중첩 클래스 적용
- Exam06.java : Collection API - ArrayList6 --> 익명 중첩 클래스 적용
- Exam07.java : Collection API - Stack
- Exam08.java : Collection API - Queue
- Exam09.java : Collection API - List vs Set
- Exam10.java : Collection API - 해시코드와 HashSet => hashCode(), equals() 재정의하기 전
- Exam11.java : Collection API - 해시코드와 HashSet => hashCode(), equals() 재정의한 후
- Exam12.java : Collection API - HashMap
- Exam13.java : Collection API - HashMap2 => 사용자 정의 클래스를 key로 사용하기
- Exam14.java : Collection API - HashMap2 => MyKey의 hashCode()와 equals() 재정의하기
- Exam15.java : HashMap - entry set으로 데이터 꺼내기
- Exam16.java : HashMap - entry set으로 데이터 꺼내기2
- Exam17.java : HashMap - 값 만 꺼내기
- Exam18.java : HashMap - 키 만 꺼내기

##step22
- exam01
	- Test01.java : 파일 정보 다루기
	- Test02.java : 파일 생성, 삭제
	- Test03.java : 디렉토리에 있는 모든 파일(디렉토리 포함) 목록을 알아내기
	- Test04.java : 디렉토리에 있는 파일 목록(디렉토리 제외)을 알아내기
	- Test05.java : 디렉토리에 있는 파일 목록(디렉토리 제외)을 알아내기
	- Test06.java : .txt 확장자를 갖는 파일명만 출력하라!
	- Test07.java : 현재 폴더 및 하위 폴더까지 뒤져서 .class 파일의 이름을 출력하라.
	- Test08.java : 주어진 폴더를 뒤져서 중첩 클래스 파일만 이름을 출력하라.
- exam02
	- Test01.java : 바이트 출력하기
	- Test02.java : 바이트 출력하기2
	- Test03.java : 바이트 출력하기3
	- Test04.java : 바이트 출력하기4
	- Test05.java : 바이트 읽기
	- Test06.java : 바이트 읽기2
	- Test07.java : 바이트 읽기3
	- Test08.java : 바이트 읽기4
- exam03
	- Test01.java : 바이트 값을 메모리(바이트 배열)로 출력하기
	- Test02.java : 메모리(바이트 배열)에 있는 바이트 값을 스트림 API를 사용해서 읽기
- exam04
	- Test01.java : 원시 타입 값을 출력하기
	- Test02.java : 원시 타입 값을 출력하기 - Refactoring(코드 개선) : 메서드 사용
	- Test03.java : 원시 타입 값을 출력하기 - Refactoring(코드 개선) : 클래스 사용
	- Test04.java : 원시 타입 값을 출력하기 - Refactoring(코드 개선) : 스태틱 변수 사용
	- Test05.java : 원시 타입 값을 출력하기 - Refactoring(코드 개선) : 인스턴스 멤버
	- Test06.java : 원시 타입 값을 출력하기 - Refactoring(코드 개선) : 상속
	- Test07.java : 원시 타입 값을 출력하기 - Refactoring(코드 개선) : Decorator 패턴
	- Test08.java : 원시 타입 값을 읽기
- exam05
	- Test01.java : 원시 타입 값을 출력하기 - Java에서 제공하는 데코레이터 사용하기
	- Test02.java : 원시 타입 값을 읽기 - Java에서 제공하는 데코레이터 사용하기
	- Test03.java : 대용량 데이터 읽기 - 데코레이터 사용 전
	- Test04.java : 대용량 데이터 읽기 - 버퍼링 데코레이터 사용 후
	- Test05.java : 대용량 데이터 읽기 - Java 버퍼링 데코레이터 사용
	- Test06.java : 대용량 데이터 쓰기 - 버퍼링 데코레이터 사용 전
	- Test07.java : 대용량 데이터 쓰기 - 버퍼링 데코레이터 사용 후
	- Test08.java : 인스턴스 출력하기
	- Test09.java : 인스턴스 읽기
	- Test10.java : 인스턴스 출력하기 - ObjectOutputStream 데코레이터 사용
	- Test11.java : 인스턴스 읽기 - ObjectInputStream 데코레이터 사용
-exam06
	- Test01.java : 문자 출력하기
	- Test02.java : 문자 읽기

##step23
- step01 : 인터페이스 사용 전
- step02 : 인터페이스 사용 전
- step03 : 상속을 이용하여 호출 규칙을 정의한다.
- step04 : HelloJp 처럼 이미 다른 클래스를 상속 받는 경우 해결책!
- step05 : 인터페이스를 이용한 호출 규칙 정하기

##step24 - 인터페이스 구현

##step25
- Test01.java : 클래스 정보 알아내기
- Test02.java : 클래스 정보 알아내기 2
- Test03.java : 클래스 정보를 통해서 인스턴스 생성하기
- Test04.java : Reflection API - 메서드 정보 추출하기
- Test05.java : Reflection API - 메서드 정보 추출하기2
- Test06.java : Reflection API - 메서드 정보 추출하기3 => 패키지 멤버 클래스도 inner 클래스와 같다. 
- Test07.java : Reflection API - 특정 메서드만 알아내기
- Test08.java : Reflection API - 메서드 호출하기

##step26
- exam01 : 제네릭 사용 전 문제점
- exam02 : 제네릭(Generic) 적용 => 타입 이름을 받을 변수를 지정한다.
- exam03 : 제네릭(Generic) 적용 => 값의 범위를 한정하기
- exam04 : 제네릭 적요 => wildcard 타입 지정

##step27
- exam01 : 클래스 파일로부터 애노테이션 정보를 추출하기 
- exam02 : 애노테이션의 유지 정책 확인하기
- exam03 
	- Test01.java : 실행 중에 애노테이션 정보 추출하기
	- Test02.java : 클래스에서 특정 애노테이셔만 추출하기 
- exam04 : 애노테이션을 사용하는 다양한 방법
- exam05 : 애노테이션을 사용하는 다양한 방법2
- exam06 : 애노테이션을 사용하는 다양한 방법3
- exam07 : 애노테이션을 사용하는 다양한 방법4

